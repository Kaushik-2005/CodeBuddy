"""
Code Writing and Generation Tools for CodeBuddy
"""
import os
import ast
import re
from typing import Dict, List, Optional, Any
from datetime import datetime


class CodeGeneratorTool:
    """Generate code from natural language descriptions"""
    
    def execute(self, description: str, language: str = "python", filepath: str = None) -> str:
        """Generate code based on description"""
        try:
            if language.lower() != "python":
                return f"âŒ Currently only Python code generation is supported"
            
            # Generate code based on description
            code = self._generate_python_code(description)
            
            if filepath:
                # Write to file
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(code)
                return f"âœ… Generated Python code and saved to {filepath}\n\nðŸ“ **Generated Code:**\n```python\n{code}\n```"
            else:
                return f"âœ… Generated Python code:\n\n```python\n{code}\n```"
                
        except Exception as e:
            return f"âŒ Code generation failed: {e}"
    
    def _generate_python_code(self, description: str) -> str:
        """Generate Python code based on description"""
        description_lower = description.lower()
        
        # Class generation
        if "class" in description_lower:
            return self._generate_class(description)
        
        # Function generation
        elif "function" in description_lower or "def" in description_lower:
            return self._generate_function(description)
        
        # Calculator/math app
        elif "calculator" in description_lower:
            return self._generate_calculator()
        
        # Web scraper
        elif "scraper" in description_lower or "scrape" in description_lower:
            return self._generate_web_scraper()
        
        # API client
        elif "api" in description_lower and "client" in description_lower:
            return self._generate_api_client()
        
        # Data analysis
        elif "data analysis" in description_lower or "pandas" in description_lower:
            return self._generate_data_analysis()
        
        # Web app
        elif "web app" in description_lower or "flask" in description_lower:
            return self._generate_flask_app()
        
        # CLI tool
        elif "cli" in description_lower or "command line" in description_lower:
            return self._generate_cli_tool()
        
        # Database operations
        elif "database" in description_lower or "sqlite" in description_lower:
            return self._generate_database_code()
        
        # File operations
        elif "file" in description_lower and ("read" in description_lower or "write" in description_lower):
            return self._generate_file_operations()
        
        # Generic script
        else:
            return self._generate_generic_script(description)
    
    def _generate_class(self, description: str) -> str:
        """Generate a Python class"""
        class_name = self._extract_class_name(description)
        return f'''#!/usr/bin/env python3
"""
{class_name} - Generated by CodeBuddy
"""

class {class_name}:
    """A {class_name.lower()} class"""
    
    def __init__(self):
        """Initialize the {class_name.lower()}"""
        pass
    
    def __str__(self):
        """String representation"""
        return f"{class_name}()"
    
    def __repr__(self):
        """Developer representation"""
        return self.__str__()


# Example usage
if __name__ == "__main__":
    obj = {class_name}()
    print(obj)
'''
    
    def _generate_function(self, description: str) -> str:
        """Generate a Python function"""
        func_name = self._extract_function_name(description)
        return f'''#!/usr/bin/env python3
"""
{func_name} - Generated by CodeBuddy
"""

def {func_name}():
    """
    {description}
    """
    # TODO: Implement function logic
    pass


# Example usage
if __name__ == "__main__":
    result = {func_name}()
    print(f"Result: {{result}}")
'''
    
    def _generate_calculator(self) -> str:
        """Generate a calculator application"""
        return '''#!/usr/bin/env python3
"""
Calculator - Generated by CodeBuddy
A simple calculator with basic arithmetic operations
"""

class Calculator:
    """A simple calculator class"""
    
    def add(self, a: float, b: float) -> float:
        """Add two numbers"""
        return a + b
    
    def subtract(self, a: float, b: float) -> float:
        """Subtract two numbers"""
        return a - b
    
    def multiply(self, a: float, b: float) -> float:
        """Multiply two numbers"""
        return a * b
    
    def divide(self, a: float, b: float) -> float:
        """Divide two numbers"""
        if b == 0:
            raise ValueError("Cannot divide by zero")
        return a / b
    
    def power(self, a: float, b: float) -> float:
        """Raise a to the power of b"""
        return a ** b
    
    def sqrt(self, a: float) -> float:
        """Calculate square root"""
        if a < 0:
            raise ValueError("Cannot calculate square root of negative number")
        return a ** 0.5


def main():
    """Main calculator interface"""
    calc = Calculator()
    
    print("ðŸ§® Simple Calculator")
    print("Operations: +, -, *, /, **, sqrt")
    print("Type 'quit' to exit")
    
    while True:
        try:
            expression = input("\\nEnter calculation: ").strip()
            
            if expression.lower() == 'quit':
                break
            
            # Simple expression evaluation (be careful with eval in production!)
            if expression.startswith('sqrt(') and expression.endswith(')'):
                num = float(expression[5:-1])
                result = calc.sqrt(num)
            else:
                # Replace ** with power method for safety
                result = eval(expression)
            
            print(f"Result: {result}")
            
        except Exception as e:
            print(f"Error: {e}")
    
    print("ðŸ‘‹ Thanks for using the calculator!")


if __name__ == "__main__":
    main()
'''
    
    def _generate_web_scraper(self) -> str:
        """Generate a web scraper"""
        return '''#!/usr/bin/env python3
"""
Web Scraper - Generated by CodeBuddy
A simple web scraper using requests and BeautifulSoup
"""

import requests
from bs4 import BeautifulSoup
import time
from urllib.parse import urljoin, urlparse


class WebScraper:
    """A simple web scraper class"""
    
    def __init__(self, delay: float = 1.0):
        """Initialize scraper with delay between requests"""
        self.delay = delay
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
    
    def scrape_page(self, url: str) -> dict:
        """Scrape a single page"""
        try:
            response = self.session.get(url)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Extract basic information
            data = {
                'url': url,
                'title': soup.title.string if soup.title else 'No title',
                'headings': [h.get_text().strip() for h in soup.find_all(['h1', 'h2', 'h3'])],
                'links': [urljoin(url, a.get('href')) for a in soup.find_all('a', href=True)],
                'text_content': soup.get_text().strip()[:1000]  # First 1000 chars
            }
            
            time.sleep(self.delay)  # Be respectful
            return data
            
        except Exception as e:
            return {'url': url, 'error': str(e)}
    
    def scrape_multiple(self, urls: list) -> list:
        """Scrape multiple pages"""
        results = []
        for url in urls:
            print(f"Scraping: {url}")
            result = self.scrape_page(url)
            results.append(result)
        return results


# Example usage
if __name__ == "__main__":
    scraper = WebScraper(delay=1.0)
    
    # Example URLs (replace with actual URLs)
    urls = [
        "https://httpbin.org/html",
        "https://example.com"
    ]
    
    results = scraper.scrape_multiple(urls)
    
    for result in results:
        if 'error' in result:
            print(f"âŒ Error scraping {result['url']}: {result['error']}")
        else:
            print(f"âœ… Scraped: {result['title']}")
            print(f"   Headings: {len(result['headings'])}")
            print(f"   Links: {len(result['links'])}")
'''
    
    def _generate_api_client(self) -> str:
        """Generate an API client"""
        return '''#!/usr/bin/env python3
"""
API Client - Generated by CodeBuddy
A simple REST API client
"""

import requests
import json
from typing import Dict, Any, Optional


class APIClient:
    """A simple REST API client"""
    
    def __init__(self, base_url: str, api_key: Optional[str] = None):
        """Initialize API client"""
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        
        if api_key:
            self.session.headers.update({'Authorization': f'Bearer {api_key}'})
        
        self.session.headers.update({
            'Content-Type': 'application/json',
            'User-Agent': 'CodeBuddy-API-Client/1.0'
        })
    
    def get(self, endpoint: str, params: Optional[Dict] = None) -> Dict[str, Any]:
        """Make GET request"""
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        try:
            response = self.session.get(url, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            return {'error': str(e)}
    
    def post(self, endpoint: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Make POST request"""
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        try:
            response = self.session.post(url, json=data)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            return {'error': str(e)}
    
    def put(self, endpoint: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Make PUT request"""
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        try:
            response = self.session.put(url, json=data)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            return {'error': str(e)}
    
    def delete(self, endpoint: str) -> Dict[str, Any]:
        """Make DELETE request"""
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        try:
            response = self.session.delete(url)
            response.raise_for_status()
            return {'success': True, 'status_code': response.status_code}
        except requests.exceptions.RequestException as e:
            return {'error': str(e)}


# Example usage
if __name__ == "__main__":
    # Example with JSONPlaceholder API
    client = APIClient("https://jsonplaceholder.typicode.com")
    
    # Get all posts
    posts = client.get("posts")
    if 'error' not in posts:
        print(f"âœ… Retrieved {len(posts)} posts")
    
    # Get specific post
    post = client.get("posts/1")
    if 'error' not in post:
        print(f"âœ… Post title: {post.get('title', 'No title')}")
    
    # Create new post
    new_post = {
        'title': 'Test Post',
        'body': 'This is a test post created by CodeBuddy',
        'userId': 1
    }
    
    result = client.post("posts", new_post)
    if 'error' not in result:
        print(f"âœ… Created post with ID: {result.get('id')}")
'''
    
    def _extract_class_name(self, description: str) -> str:
        """Extract class name from description"""
        # Look for class name patterns
        match = re.search(r'class\s+(\w+)', description, re.IGNORECASE)
        if match:
            return match.group(1).capitalize()
        
        # Extract from common patterns
        words = description.split()
        for word in words:
            if word.lower() not in ['a', 'an', 'the', 'for', 'to', 'create', 'make', 'build']:
                return word.capitalize().replace(' ', '')
        
        return "MyClass"
    
    def _extract_function_name(self, description: str) -> str:
        """Extract function name from description"""
        # Look for function name patterns
        match = re.search(r'function\s+(\w+)', description, re.IGNORECASE)
        if match:
            return match.group(1).lower()
        
        match = re.search(r'def\s+(\w+)', description, re.IGNORECASE)
        if match:
            return match.group(1).lower()
        
        # Generate from description
        words = description.lower().split()
        action_words = ['calculate', 'process', 'handle', 'manage', 'create', 'build', 'make']
        
        for word in words:
            if word in action_words:
                return word
        
        return "my_function"

    def _generate_data_analysis(self) -> str:
        """Generate data analysis code"""
        return '''#!/usr/bin/env python3
"""
Data Analysis - Generated by CodeBuddy
A simple data analysis script using pandas
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Dict, Any


class DataAnalyzer:
    """A simple data analysis class"""

    def __init__(self, data_file: str = None):
        """Initialize with optional data file"""
        self.df = None
        if data_file:
            self.load_data(data_file)

    def load_data(self, file_path: str) -> bool:
        """Load data from file"""
        try:
            if file_path.endswith('.csv'):
                self.df = pd.read_csv(file_path)
            elif file_path.endswith('.json'):
                self.df = pd.read_json(file_path)
            elif file_path.endswith('.xlsx'):
                self.df = pd.read_excel(file_path)
            else:
                raise ValueError("Unsupported file format")

            print(f"âœ… Loaded data: {self.df.shape[0]} rows, {self.df.shape[1]} columns")
            return True

        except Exception as e:
            print(f"âŒ Error loading data: {e}")
            return False

    def basic_info(self) -> Dict[str, Any]:
        """Get basic information about the dataset"""
        if self.df is None:
            return {"error": "No data loaded"}

        return {
            "shape": self.df.shape,
            "columns": list(self.df.columns),
            "dtypes": self.df.dtypes.to_dict(),
            "missing_values": self.df.isnull().sum().to_dict(),
            "memory_usage": self.df.memory_usage(deep=True).sum()
        }

    def summary_stats(self) -> pd.DataFrame:
        """Get summary statistics"""
        if self.df is None:
            return pd.DataFrame()
        return self.df.describe()

    def plot_distributions(self, columns: list = None):
        """Plot distributions of numeric columns"""
        if self.df is None:
            print("âŒ No data loaded")
            return

        numeric_cols = self.df.select_dtypes(include=[np.number]).columns
        if columns:
            numeric_cols = [col for col in columns if col in numeric_cols]

        if len(numeric_cols) == 0:
            print("âŒ No numeric columns found")
            return

        fig, axes = plt.subplots(len(numeric_cols), 1, figsize=(10, 6*len(numeric_cols)))
        if len(numeric_cols) == 1:
            axes = [axes]

        for i, col in enumerate(numeric_cols):
            self.df[col].hist(bins=30, ax=axes[i])
            axes[i].set_title(f'Distribution of {col}')
            axes[i].set_xlabel(col)
            axes[i].set_ylabel('Frequency')

        plt.tight_layout()
        plt.show()


# Example usage
if __name__ == "__main__":
    # Create sample data for demonstration
    np.random.seed(42)
    sample_data = pd.DataFrame({
        'age': np.random.randint(18, 80, 1000),
        'income': np.random.normal(50000, 15000, 1000),
        'score': np.random.uniform(0, 100, 1000),
        'category': np.random.choice(['A', 'B', 'C'], 1000)
    })

    # Save sample data
    sample_data.to_csv('sample_data.csv', index=False)
    print("ðŸ“Š Created sample data file: sample_data.csv")

    # Analyze the data
    analyzer = DataAnalyzer('sample_data.csv')

    # Basic info
    info = analyzer.basic_info()
    print("\\nðŸ“‹ Dataset Info:")
    for key, value in info.items():
        print(f"  {key}: {value}")

    # Summary statistics
    print("\\nðŸ“ˆ Summary Statistics:")
    print(analyzer.summary_stats())
'''

    def _generate_flask_app(self) -> str:
        """Generate a Flask web application"""
        return '''#!/usr/bin/env python3
"""
Flask Web App - Generated by CodeBuddy
A simple Flask web application
"""

from flask import Flask, request, jsonify
import os
from datetime import datetime

app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY', 'dev-secret-key-change-in-production')

# In-memory storage (use database in production)
data_store = []

@app.route('/')
def index():
    """Home page"""
    return """
    <html>
    <head><title>CodeBuddy Flask App</title></head>
    <body>
        <h1>ðŸš€ CodeBuddy Flask App</h1>
        <p>A simple web application generated by CodeBuddy</p>
        <h2>API Endpoints</h2>
        <ul>
            <li><a href="/api/items">GET /api/items</a> - Get all items</li>
            <li>POST /api/items - Add new item</li>
            <li><a href="/api/health">GET /api/health</a> - Health check</li>
        </ul>
    </body>
    </html>
    """

@app.route('/api/items', methods=['GET'])
def api_get_items():
    """API: Get all items"""
    return jsonify({
        'success': True,
        'count': len(data_store),
        'items': data_store
    })

@app.route('/api/items', methods=['POST'])
def api_add_item():
    """API: Add new item"""
    data = request.get_json()

    if not data or not data.get('title'):
        return jsonify({'success': False, 'error': 'Title is required'}), 400

    item = {
        'id': len(data_store) + 1,
        'title': data.get('title', '').strip(),
        'content': data.get('content', '').strip(),
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }

    data_store.append(item)

    return jsonify({
        'success': True,
        'message': 'Item added successfully',
        'item': item
    }), 201

@app.route('/api/health')
def api_health():
    """API: Health check"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'items_count': len(data_store)
    })

if __name__ == '__main__':
    print("ðŸš€ Starting Flask app...")
    print("ðŸ“± Open http://localhost:5000 in your browser")
    app.run(debug=True, host='0.0.0.0', port=5000)
'''

    def _generate_cli_tool(self) -> str:
        """Generate a CLI tool"""
        return '''#!/usr/bin/env python3
"""
CLI Tool - Generated by CodeBuddy
A simple command-line interface tool
"""

import argparse
import sys
import os
from typing import List, Optional


class CLITool:
    """A simple CLI tool class"""

    def __init__(self):
        """Initialize CLI tool"""
        self.parser = self._create_parser()

    def _create_parser(self) -> argparse.ArgumentParser:
        """Create argument parser"""
        parser = argparse.ArgumentParser(
            description='CodeBuddy CLI Tool - A simple command-line utility',
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="""
Examples:
  %(prog)s process --input file.txt --output result.txt
  %(prog)s list --directory /path/to/dir
  %(prog)s info --verbose
            """
        )

        # Global options
        parser.add_argument('-v', '--verbose', action='store_true',
                          help='Enable verbose output')
        parser.add_argument('--version', action='version', version='%(prog)s 1.0.0')

        # Subcommands
        subparsers = parser.add_subparsers(dest='command', help='Available commands')

        # Process command
        process_parser = subparsers.add_parser('process', help='Process files')
        process_parser.add_argument('-i', '--input', required=True,
                                  help='Input file path')
        process_parser.add_argument('-o', '--output',
                                  help='Output file path')
        process_parser.add_argument('--format', choices=['json', 'csv', 'txt'],
                                  default='txt', help='Output format')

        # List command
        list_parser = subparsers.add_parser('list', help='List files')
        list_parser.add_argument('-d', '--directory', default='.',
                               help='Directory to list')
        list_parser.add_argument('-r', '--recursive', action='store_true',
                               help='List recursively')

        # Info command
        info_parser = subparsers.add_parser('info', help='Show information')

        return parser

    def run(self, args: Optional[List[str]] = None) -> int:
        """Run the CLI tool"""
        try:
            parsed_args = self.parser.parse_args(args)

            if not parsed_args.command:
                self.parser.print_help()
                return 1

            # Execute command
            if parsed_args.command == 'process':
                return self._process_command(parsed_args)
            elif parsed_args.command == 'list':
                return self._list_command(parsed_args)
            elif parsed_args.command == 'info':
                return self._info_command(parsed_args)
            else:
                print(f"âŒ Unknown command: {parsed_args.command}")
                return 1

        except KeyboardInterrupt:
            print("\\nâš ï¸ Operation cancelled by user")
            return 130
        except Exception as e:
            print(f"âŒ Error: {e}")
            return 1

    def _process_command(self, args) -> int:
        """Handle process command"""
        if args.verbose:
            print(f"ðŸ“ Processing file: {args.input}")

        try:
            # Check if input file exists
            if not os.path.exists(args.input):
                print(f"âŒ Input file not found: {args.input}")
                return 1

            # Read input file
            with open(args.input, 'r', encoding='utf-8') as f:
                content = f.read()

            # Process content (example: count lines and words)
            lines = content.split('\\n')
            words = content.split()

            result = {
                'file': args.input,
                'lines': len(lines),
                'words': len(words),
                'characters': len(content)
            }

            # Output result
            if args.output:
                with open(args.output, 'w', encoding='utf-8') as f:
                    if args.format == 'json':
                        import json
                        json.dump(result, f, indent=2)
                    else:
                        f.write(f"File: {result['file']}\\n")
                        f.write(f"Lines: {result['lines']}\\n")
                        f.write(f"Words: {result['words']}\\n")
                        f.write(f"Characters: {result['characters']}\\n")

                print(f"âœ… Results saved to: {args.output}")
            else:
                print("ðŸ“Š Processing Results:")
                print(f"  Lines: {result['lines']}")
                print(f"  Words: {result['words']}")
                print(f"  Characters: {result['characters']}")

            return 0

        except Exception as e:
            print(f"âŒ Processing failed: {e}")
            return 1

    def _list_command(self, args) -> int:
        """Handle list command"""
        if args.verbose:
            print(f"ðŸ“‚ Listing directory: {args.directory}")

        try:
            if not os.path.exists(args.directory):
                print(f"âŒ Directory not found: {args.directory}")
                return 1

            if args.recursive:
                for root, dirs, files in os.walk(args.directory):
                    level = root.replace(args.directory, '').count(os.sep)
                    indent = ' ' * 2 * level
                    print(f"{indent}ðŸ“ {os.path.basename(root)}/")
                    subindent = ' ' * 2 * (level + 1)
                    for file in files:
                        print(f"{subindent}ðŸ“„ {file}")
            else:
                items = os.listdir(args.directory)
                for item in sorted(items):
                    path = os.path.join(args.directory, item)
                    if os.path.isdir(path):
                        print(f"ðŸ“ {item}/")
                    else:
                        print(f"ðŸ“„ {item}")

            return 0

        except Exception as e:
            print(f"âŒ Listing failed: {e}")
            return 1

    def _info_command(self, args) -> int:
        """Handle info command"""
        print("â„¹ï¸ CLI Tool Information:")
        print(f"  Python version: {sys.version}")
        print(f"  Current directory: {os.getcwd()}")
        print(f"  Platform: {sys.platform}")

        if args.verbose:
            print(f"  Python executable: {sys.executable}")
            print(f"  Python path: {sys.path[:3]}...")  # First 3 entries

        return 0


def main():
    """Main entry point"""
    tool = CLITool()
    return tool.run()


if __name__ == "__main__":
    sys.exit(main())
'''

    def _generate_database_code(self) -> str:
        """Generate database operations code"""
        return '''#!/usr/bin/env python3
"""
Database Operations - Generated by CodeBuddy
Simple database operations using SQLite
"""

import sqlite3
import os
from typing import List, Dict, Any, Optional
from contextlib import contextmanager


class DatabaseManager:
    """Simple database manager for SQLite"""

    def __init__(self, db_path: str = "app.db"):
        """Initialize database manager"""
        self.db_path = db_path
        self.init_database()

    def init_database(self):
        """Initialize database with basic tables"""
        with self.get_connection() as conn:
            cursor = conn.cursor()

            # Create users table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    email TEXT UNIQUE NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)

            # Create posts table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS posts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    title TEXT NOT NULL,
                    content TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id)
                )
            """)

            conn.commit()

    @contextmanager
    def get_connection(self):
        """Get database connection with context manager"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row  # Enable dict-like access
        try:
            yield conn
        finally:
            conn.close()

    def create_user(self, name: str, email: str) -> int:
        """Create a new user"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO users (name, email) VALUES (?, ?)",
                (name, email)
            )
            conn.commit()
            return cursor.lastrowid

    def get_user(self, user_id: int) -> Optional[Dict[str, Any]]:
        """Get user by ID"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_all_users(self) -> List[Dict[str, Any]]:
        """Get all users"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM users ORDER BY created_at DESC")
            return [dict(row) for row in cursor.fetchall()]

    def create_post(self, user_id: int, title: str, content: str) -> int:
        """Create a new post"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO posts (user_id, title, content) VALUES (?, ?, ?)",
                (user_id, title, content)
            )
            conn.commit()
            return cursor.lastrowid

    def get_user_posts(self, user_id: int) -> List[Dict[str, Any]]:
        """Get all posts by user"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT p.*, u.name as author_name
                FROM posts p
                JOIN users u ON p.user_id = u.id
                WHERE p.user_id = ?
                ORDER BY p.created_at DESC
            """, (user_id,))
            return [dict(row) for row in cursor.fetchall()]


# Example usage
if __name__ == "__main__":
    db = DatabaseManager("example.db")

    # Create a user
    user_id = db.create_user("John Doe", "john@example.com")
    print(f"Created user with ID: {user_id}")

    # Create a post
    post_id = db.create_post(user_id, "My First Post", "Hello, World!")
    print(f"Created post with ID: {post_id}")

    # Get user and posts
    user = db.get_user(user_id)
    posts = db.get_user_posts(user_id)

    print(f"User: {user}")
    print(f"Posts: {posts}")
'''

    def _generate_file_operations(self) -> str:
        """Generate file operations code"""
        return '''#!/usr/bin/env python3
"""
File Operations - Generated by CodeBuddy
Comprehensive file handling utilities
"""

import os
import shutil
import json
import csv
from pathlib import Path
from typing import List, Dict, Any, Optional, Generator


class FileOperations:
    """Comprehensive file operations utility"""

    @staticmethod
    def read_text_file(filepath: str, encoding: str = 'utf-8') -> Optional[str]:
        """Read text file safely"""
        try:
            with open(filepath, 'r', encoding=encoding) as f:
                return f.read()
        except FileNotFoundError:
            print(f"File not found: {filepath}")
            return None
        except UnicodeDecodeError as e:
            print(f"Encoding error: {e}")
            return None

    @staticmethod
    def write_text_file(filepath: str, content: str, encoding: str = 'utf-8') -> bool:
        """Write text file safely"""
        try:
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(filepath), exist_ok=True)

            with open(filepath, 'w', encoding=encoding) as f:
                f.write(content)
            return True
        except Exception as e:
            print(f"Error writing file: {e}")
            return False

    @staticmethod
    def read_json_file(filepath: str) -> Optional[Dict[str, Any]]:
        """Read JSON file"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"JSON file not found: {filepath}")
            return None
        except json.JSONDecodeError as e:
            print(f"Invalid JSON: {e}")
            return None

    @staticmethod
    def write_json_file(filepath: str, data: Dict[str, Any], indent: int = 2) -> bool:
        """Write JSON file"""
        try:
            os.makedirs(os.path.dirname(filepath), exist_ok=True)

            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=indent, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"Error writing JSON: {e}")
            return False

    @staticmethod
    def read_csv_file(filepath: str) -> List[Dict[str, str]]:
        """Read CSV file as list of dictionaries"""
        try:
            with open(filepath, 'r', encoding='utf-8', newline='') as f:
                reader = csv.DictReader(f)
                return list(reader)
        except FileNotFoundError:
            print(f"CSV file not found: {filepath}")
            return []
        except Exception as e:
            print(f"Error reading CSV: {e}")
            return []

    @staticmethod
    def write_csv_file(filepath: str, data: List[Dict[str, str]], fieldnames: List[str] = None) -> bool:
        """Write CSV file from list of dictionaries"""
        try:
            if not data:
                return False

            if fieldnames is None:
                fieldnames = list(data[0].keys())

            os.makedirs(os.path.dirname(filepath), exist_ok=True)

            with open(filepath, 'w', encoding='utf-8', newline='') as f:
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(data)
            return True
        except Exception as e:
            print(f"Error writing CSV: {e}")
            return False

    @staticmethod
    def copy_file(source: str, destination: str) -> bool:
        """Copy file safely"""
        try:
            os.makedirs(os.path.dirname(destination), exist_ok=True)
            shutil.copy2(source, destination)
            return True
        except Exception as e:
            print(f"Error copying file: {e}")
            return False

    @staticmethod
    def move_file(source: str, destination: str) -> bool:
        """Move file safely"""
        try:
            os.makedirs(os.path.dirname(destination), exist_ok=True)
            shutil.move(source, destination)
            return True
        except Exception as e:
            print(f"Error moving file: {e}")
            return False

    @staticmethod
    def delete_file(filepath: str) -> bool:
        """Delete file safely"""
        try:
            os.remove(filepath)
            return True
        except FileNotFoundError:
            print(f"File not found: {filepath}")
            return False
        except Exception as e:
            print(f"Error deleting file: {e}")
            return False

    @staticmethod
    def list_files(directory: str, pattern: str = "*", recursive: bool = False) -> List[str]:
        """List files in directory"""
        try:
            path = Path(directory)
            if recursive:
                return [str(p) for p in path.rglob(pattern) if p.is_file()]
            else:
                return [str(p) for p in path.glob(pattern) if p.is_file()]
        except Exception as e:
            print(f"Error listing files: {e}")
            return []

    @staticmethod
    def get_file_info(filepath: str) -> Optional[Dict[str, Any]]:
        """Get file information"""
        try:
            stat = os.stat(filepath)
            return {
                'size': stat.st_size,
                'modified': stat.st_mtime,
                'created': stat.st_ctime,
                'is_file': os.path.isfile(filepath),
                'is_dir': os.path.isdir(filepath),
                'exists': os.path.exists(filepath)
            }
        except Exception as e:
            print(f"Error getting file info: {e}")
            return None


# Example usage
if __name__ == "__main__":
    ops = FileOperations()

    # Test text operations
    ops.write_text_file("test.txt", "Hello, World!")
    content = ops.read_text_file("test.txt")
    print(f"Text content: {content}")

    # Test JSON operations
    data = {"name": "John", "age": 30}
    ops.write_json_file("test.json", data)
    loaded_data = ops.read_json_file("test.json")
    print(f"JSON data: {loaded_data}")

    # Test CSV operations
    csv_data = [
        {"name": "John", "age": "30"},
        {"name": "Jane", "age": "25"}
    ]
    ops.write_csv_file("test.csv", csv_data)
    loaded_csv = ops.read_csv_file("test.csv")
    print(f"CSV data: {loaded_csv}")
'''

    def _generate_generic_script(self, description: str) -> str:
        """Generate a generic script based on description"""
        return f'''#!/usr/bin/env python3
"""
{description.title()} - Generated by CodeBuddy
"""

import sys
import os
from typing import Any, Optional


def main():
    """Main function for {description.lower()}"""
    print("ðŸš€ Starting {description.lower()}...")

    try:
        # TODO: Implement the logic for: {description}
        result = process_data()

        print(f"âœ… {description.title()} completed successfully!")
        print(f"Result: {{result}}")

    except Exception as e:
        print(f"âŒ Error in {description.lower()}: {{e}}")
        return 1

    return 0


def process_data() -> Any:
    """Process data according to requirements"""
    # TODO: Implement data processing logic
    return "Processing completed"


def helper_function(data: Any) -> Any:
    """Helper function for data processing"""
    # TODO: Implement helper logic
    return data


if __name__ == "__main__":
    sys.exit(main())
'''
